<!doctype html>
<html lang="en">
  <head>
    <!-- Required meta tags -->
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">

    <!-- Bootstrap CSS -->
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.1.0/dist/css/bootstrap.min.css" rel="stylesheet" integrity="sha384-KyZXEAg3QhqLMpG8r+8fhAXLRk2vvoC2f3B09zVXn8CA5QIVfZOJ3BCsw2P0p/We" crossorigin="anonymous">

    <title>Waves LPOS distributer Service - WLDaaS</title>

		<style>
			.form-check-input:checked {
    		background-color: darkcyan;
    		border-color: dark;
			}
		</style>

  </head>

  <body>

    <!-- Optional JavaScript; choose one of the two! -->

    <!-- Option 1: Bootstrap Bundle with Popper -->
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.1.0/dist/js/bootstrap.bundle.min.js" integrity="sha384-U1DAWAznBHeqEIlVSCgzq+c9gqGAJn5c/t99JyeKa9xxaYpSvHU5awsuZVVFIhvj" crossorigin="anonymous"></script>

    <!-- Option 2: Separate Popper and Bootstrap JS -->
    <!--
    <script src="https://cdn.jsdelivr.net/npm/@popperjs/core@2.9.3/dist/umd/popper.min.js" integrity="sha384-eMNCOe7tC1doHpGoWe/6oMVemdAVTMs2xqW4mwXrXsW0L84Iytr2wi5v2QjrP/xp" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.1.0/dist/js/bootstrap.min.js" integrity="sha384-cn7l7gDp0eyniUwwAZgrzD06kc/tftFf19TOAs2zVinnD/C7E91j9yyk5//jjpt/" crossorigin="anonymous"></script>
    -->

    <!-- <script>var exports = {};</script> -->

    <script src='https://requirejs.org/docs/release/2.1.5/comments/require.js'></script>


    <script>
    	requirejs.config({
  			paths: {
    			'signer': 'https://cdn.jsdelivr.net/npm/@waves/signer/dist/signer.min',
   				//'provider-keeper': 'https://cdn.jsdelivr.net/npm/@waves/provider-keeper/dist/provider-keeper',
   				'provider-keeper': 'https://cdn.jsdelivr.net/npm/@waves/provider-keeper/dist/provider-keeper.min',
   				'axios': 'https://cdn.jsdelivr.net/npm/axios/dist/axios.min.js'
				},
    		shim: {
					keeper: {
					deps: ['signer'],
					},
				},
			});
		</script>

 

  <!-- ############################ MAIN FRONTEND START ############################ -->

<div class="bg-dark bg-gradient bg-opacity-85 text-white">


<p class="fw-normal text-info  text-center fs-2">WLDaaS</p>
<p class="fw-light text-center text-opacity-75 text-info fs-5">You run your node, let WLDaaS control your fee distribution</p>
<p class="fw-light text-center text-light text-opacity-75 fst-italic fs-6">This service requires the Waves Keeper browser extension</p>


<!-- <center><h3><br><span class="text-warning bg-dark">***** CURRENTLY UNDERGOING TESTING *****</span><br><br></h3></center> -->
<!-- <center><h3><br><span class="text-warning bg-dark">!!!!!! UNDER CONSTRUCTION CURRENTLY !!!!!!</span><br><br></h3></center> -->



<form>

	<div class="container bg-dark bg-gradient bg-opacity-70">

  		<div class="row">
  			<div class="col-md-4">
  				<br>
 					<label for="nodewallet" class="form-label text-white text-opacity-75 fw-light">Wallet address</label>
  				<input type="text" min="1" class="form-control form-control-sm bg-secondary text-white text-opacity-85" id="nodewallet" placeholder="" disabled>
    		</div>
    		<div class="col-md-2">
    			<br>
 					<label for="feeshare" class="form-label text-warning fw-light">Fee share %</label>
  				<input type="number" min="1" class="form-control form-control-sm" id="feeshare" oninput="validity.valid||(value='');">
    		</div>
    		<div class="col-md-2">
    			<br>
      		<label for="rewardshare" class="form-label text-warning fw-light">Block reward share %</label>
  				<input type="number" min="1" class="form-control form-control-sm" id="rewardshare" oninput="validity.valid||(value='');">
    		</div>
    	</div>

  		<div class="row">
    		<div class="col-md-2">
      			<label for="startblock" class="form-label text-warning fw-light">1<sup>st</sup> leaser block</label>
  				<input type="number" min="1" class="form-control form-control-sm" id="startblock" >
    		</div>
    		<div class="col-md-2">
 				<label for="payblock" class="form-label text-warning fw-light">Start block</label>
  				<input type="number" min="1" class="form-control form-control-sm" id="payblock" >
    		</div>
    		<div class="col-md-2">
      			<label for="stopblock" class="form-label text-warning fw-light">Stop block</label>
  				<input type="number" min="1" class="form-control form-control-sm" id="stopblock" >
    		</div>
    		<div class="col-md-2">
 				<label for="lastblock" class="form-label text-white text-opacity-75 fw-light">Last block</label>
  				<input type="number" min="1" class="form-control form-control-sm bg-secondary text-white text-opacity-85" id="lastblock" readonly>
    		</div>
    	</div>

    	<div class="row">

    		<div class=col-md-4>
    			<br>
    			<button type="submit" id="find1stleaser" onclick="find_1st_leaser(); return false;" class="btn btn-dark text-dark text-opacity-80 bg-warning bg-gradient btn-sm">get 1<sup>st</sup> lease</button>
    			<button type="submit" id="unlock1stleaser" onclick="unlock_1st_leaser(); return false;" class="btn btn-dark text-dark text-opacity-80 bg-warning bg-gradient btn-sm">unlock 1<sup>st</sup></button>

    			<button type="submit" id="reloadnext" onclick="reload_next(); return false;" class="btn btn-dark text-dark text-opacity-80 bg-warning bg-gradient btn-sm">load nextrun data
    				<span class="spinner-border spinner-border-sm" hidden></span>
    			</button>
					
					<button type="submit" id="collect" onclick="click_button_collect(); return false;" class="btn btn-dark text-dark text-opacity-80 bg-warning bg-gradient btn-sm">collect
            <span class="spinner-border spinner-border-sm" hidden></span>
          </button>

          <button type="submit" id="help" onclick="go_page('help.html'); return false;" class="btn btn-warning text-warning bg-dark bg-gradient btn-sm">?</button>
				</div>

  			<div class=col-md-2>
  				<br>
					<div class="form-check form-switch">
  					<input class="form-check-input" type="checkbox" id="pay">
  					<label class="form-check-label text-white fw-light text-opacity-75" for="pay">incl. pay proposal</label>
					</div>
					<div class="form-check form-switch">
  					<input class="form-check-input" type="checkbox" id="overwrite">
  					<label class="form-check-label text-white fw-light text-opacity-75" for="overwrite">overwrite</label>
					</div>
				</div>

  			<div class=col-md-2>
  				<br>
					<div class="form-check form-switch">
  					<input class="form-check-input" type="checkbox" id="force">
  					<label class="form-check-label text-white fw-light text-opacity-75" for="force">use last as stop</label>
  				</div>
					<div class="form-check form-switch">
  					<input class="form-check-input text-warning" type="checkbox" id="freerun">
  					<label class="form-check-label text-white fw-light text-opacity-75" for="freerun">free run</label>
					</div>
  			</div>

  		</div>

  		<br>

			<div class="row">
  			<div class="col-md-4">
  				<label for="wallet_signup" class="form-label text-white fw-light text-opacity-75">wallet address</label>
    			<input type="text" id="wallet_signup" class="form-control form-control-sm">
  			</div>
			</div>

			<div class="row">

  			<div class="col-md-2">
  				<label for="username" class="form-label text-white fw-light text-opacity-75">username</label>
    			<input type="email" minlength="6"  maxlength="60" id="username" class="form-control form-control-sm" placeholder="email@domain.com">
  			</div>
  			<div class="col-md-2">
  				<label for="password" class="form-label text-white fw-light text-opacity-75">password</label>
    			<input type="password" minlength="8"  maxlength="60" id="password" class="form-control form-control-sm" placeholder="your password here">
  			</div>
  			<div class="col-md-2">
  				<label for="repeatpwd" class="form-label"><br></label>
    			<input type="password" minlength="8"  maxlength="60" id="repeatpwd" class="form-control form-control-sm" placeholder="repeat password" hidden>
  			</div>

			</div>

			<br>

			<div class="row">

				<div class="col-md-4">

    			<button type="submit" id="login" onclick="login_account(); return false;" class="btn btn-info btn-sm text-dark text-opacity-80 bg-gradient">login
    				<span class="spinner-border spinner-border-sm" hidden></span>
    			</button>

  				<button type="submit" id="create" onclick="create_account(); return false;" class="btn btn-info btn-sm text-dark text-opacity-80 bg-gradient">signup
  					<span class="spinner-border spinner-border-sm" hidden></span>
  				</button>

  				<button type="submit" id="settings" onclick="go_settings_page(); return false;" class="btn btn-info btn-sm text-dark text-opacity-80 bg-gradient">settings</button>
  				<button type="submit" id="pwdchange" onclick="go_password_change(); return false;" class="btn btn-info btn-sm text-dark text-opacity-80 bg-gradient">change password</button>
  				
  			</div>
  		
			</div>
			<br>

  </div>

<!--
  <button type="submit" id='wavesauth' onclick="waves_keeper_transaction(); return false;">Auth with Waves Keeper</button>
-->

</form>


<!--</div>
-->




<div class=" bg-gradient text-center">
	<div class="fw-normal text-info text-opacity-75 small">Brought to you by Waves node <strong>Plukkieforger</strong></div>
	<div class="text-info text-opacity-75">'<class id="mywallet"></class>'</div>
	<p>
		<a class="nav-link text-opacity-75" href="http://www.cryptouniverse.nl">Cryptouniverse.nl</a>
	</p>
</div>



</div>




    <!-------------------------------- MY SCRIPTS & FUNCTIONS START ----------------------------------------->


<!-- <pre id='authData'></pre> -->

<script>




const env			= 'prod' //set here to test on 'dev' or 'prod' environment
//---------------------------------------------------------------------------------------------
const baseapi		= 'https://cz9kuult00.execute-api.eu-north-1.amazonaws.com' //My API gateway
const stage 		= '/' + env
const GET_path		= '/collect'
const account_path	= '/account'
const signup		= '/signup'
const login			= '/login'
const defaultwallet = '3P7ajba4wWLXq6t1G8VaoaVqbUb1dDp8fm4'
const wldaaswallet = "3P6CwqcnK1wyW5TLzD15n79KbAsqAjQZ2HH"
const mywebsite		= "Cryptouniverse.nl"
const signuparg		= 'signupsecret' //param in url in the activation link to confirm a signup
const wavespayment	= 'wavespaylink' //pay simulation param
const wavesnodes    = 'https://nodes.wavesnodes.com'
const activeleases	= '/leasing/active'
const settingspage 	= 'settings.html'
const pwdchange_page = 'pwdchange.html'
const mainpage			= 'index.html'
const formfieldarray =	[			//Define array with all formfield id's
													'nodewallet',
													'feeshare',
													'rewardshare',
													'pay',
													'stopislast'
												]
const mypaydetails =  {	
												wallet: '3P6CwqcnK1wyW5TLzD15n79KbAsqAjQZ2HH',
												collectorprice: 2000000,			//0.02 Waves
												collectandpayprice: 3000000,	//0.03 Waves
												txfee: 100000
											}

const maxblocks		= 1000000 //Max number of blocks in one run

const wavesdecimals = 8.0
let globalobject = {}


document.getElementById("mywallet").innerHTML = defaultwallet //Set my wallet address as footer when page loads

//Extract param values from URL that was used
const urlquerystring	= new URLSearchParams(window.location.search)  //Get url param string that was used
const secret 					= urlquerystring.get(signuparg)
const ww							= urlquerystring.get('wallet')
const scanstart 			= Number(urlquerystring.get('scanstartblock'))
const scanstop 				= Number(urlquerystring.get('paystopblock'))
const firstpay 				= Number(urlquerystring.get('paystartblock'))  
let feeshare				= Number(urlquerystring.get('feeshare'))  //default share from settings
let rewardshare			= Number(urlquerystring.get('rewardshare'))  //default share from settings
const blockrange			= Number(urlquerystring.get('blockwindowsize'))  //default blocks size from settings
const stopislast	  	= urlquerystring.get('stopislast')  //default setting is stopblock should be current last block
const pay	  	= urlquerystring.get('pay')
const wavespaylink		= urlquerystring.get(wavespayment) 


//Catch Globalobject if available, decode base58 hash, parse json string and add to globalobject
const globalobjectstring 			= urlquerystring.get('setglobalobject') //Catch base58 hash
if (globalobjectstring != '' && globalobjectstring != undefined && globalobjectstring != null) { //If there is value, parse json string
	globalobject = JSON.parse(atob(globalobjectstring))
}


//Function to generate a random string
//input: required string length X
//output: string composed of X chars
function makeid(length) {
	var result           = '';
	var characters       = '-ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789';
	var charactersLength = characters.length;
	for ( var i = 0; i < length; i++ ) {
		result += characters.charAt(Math.floor(Math.random() * charactersLength));
	}
	return result;
}


//Function that calculates a wled to a waves amount
//smallest waves amount is (10-8), 0.00000001 Waves
//That is 1 wavesled
//input: wled
//output: waves
function wp (wled) {
	let wavesamount = wled/Math.pow(10, wavesdecimals)
	return wavesamount
}


//Function that converts an exponential number (i.e 1-e8) to decimal (0.00000001)
//input: number
//output: decimal presented or just input number
function exptodec (exponentialNumber) {
  // sanity check - is it exponential number
  const str = exponentialNumber.toString();
  if (str.indexOf('e') !== -1) {
    const exponent = parseInt(str.split('-')[1], 10);
    // Unfortunately I can not return 1e-8 as 0.00000001, because even if I call parseFloat() on it,
    // it will still return the exponential representation
    // So I have to use .toFixed()
    const result = exponentialNumber.toFixed(exponent);
    return result;
  } else {
    return exponentialNumber;
  }
}


window.history.pushState({}, document.title, "/" + mainpage) //remove params in url bar

/* Get last blockheight of waves blockchain
 * This is an asynchronous function
 * the value is set as placeholder in some formfield id's
 */
const get_lastblock = async () => {
	const baseurl = 'https://nodes.wavesplatform.com:443'
	try {
		const response = await fetch (baseurl + '/blocks/height')
		const data = await response.json()
		const lastblockheight = parseInt(data['height']);
		document.getElementById("stopblock").placeholder = (lastblockheight-1) + ' (max)' ;
		document.getElementById("lastblock").placeholder = lastblockheight
		document.getElementById("lastblock").value = lastblockheight

		if (stopislast == 'yes') { document.getElementById("stopblock").value = lastblockheight-1 }
		currentblock = lastblockheight
	} catch (err) {

	}
}

get_lastblock() //Get height of last block from Waves blockchain


//Push values found in url params to formfields
if (ww != undefined && ww != '' && ww != null) {  //Seems we are logged in
	const id = document.getElementById("nodewallet")
	id.value = ww
	id.disabled = true	//Disable form field
	document.getElementById("wallet_signup").value = ww
  document.getElementById("wallet_signup").disabled = true
  document.getElementById("wallet_signup").classList.add('bg-gradient', 'bg-dark', 'text-white', 'text-opacity-50')

  globalobject['usernameb64'] = urlquerystring.get('username')
  document.getElementById("username").placeholder = "******************"
  document.getElementById("username").disabled = true
  document.getElementById("username").classList.add('bg-dark', 'bg-gradient', 'text-white', 'text-opacity-50')

  document.getElementById("password").placeholder = "******************"
  document.getElementById("password").disabled = true
  document.getElementById("password").classList.add('bg-dark', 'bg-gradient', 'text-white', 'text-opacity-50')

} else {
	document.getElementById("wallet_signup").placeholder = defaultwallet
}


if (scanstart != undefined && scanstart != '' && scanstart != null && scanstart > 0) {
	const id = document.getElementById("startblock")
	id.value = scanstart
	id.disabled = true
}
if (scanstop != undefined && scanstop != '' && scanstop != null && scanstop > 0) { document.getElementById("stopblock").value = scanstop }
if (firstpay != undefined && firstpay != '' && firstpay != null && firstpay > 0) { document.getElementById("payblock").value = firstpay }
if (feeshare != undefined && feeshare != '' && feeshare != null && feeshare > 0) { document.getElementById("feeshare").value = feeshare }
if (rewardshare != undefined && rewardshare != '' && rewardshare != null && rewardshare > 0) { document.getElementById("rewardshare").value = rewardshare }
if (stopislast == 'yes') { document.getElementById("force").checked = true }
if (pay == 'yes') { document.getElementById("pay").checked = true }




function spinner (run='', buttonid) {

	let spinning
  const id = document.getElementById(buttonid)
  const sb = id.getElementsByClassName("spinner-border")

  if (sb[0].hidden == true) {
  	spinning = false
  } else {
  	spinning = true
  }

  if (run == 'start' && spinning == false) {			//Start spinning on button
  	sb[0].hidden = false
  } else if (run == 'stop' && spinning == true) {	//Stop spinning on button
  	sb[0].hidden = true
  }
}


/* Grabs all form field values
 * It creates one url parameterstring of values
 * and sets the values to the formfields
 * Deep validation checking is done in the lambda function
 * If there was a batchinfo file found (a collector run was done yet),
 * the batchdata was received in the response body
 */
function create_paramstring_from_body (body) {

	const waveswallet = body['waveswallet']
	const bd = body['batchdata']
	const defaults = body['defaults']
	let string = '?wallet=' + waveswallet

	for (item in bd) {	//Get batchdata items
		if (bd[item] != '') {	//Get value and add to url
			string += '&' + item + '=' + bd[item]
		}
	}

	if (defaults != 'none') {  //Get default settings that were set and saved
		for (item in defaults) {
			if (defaults[item] != '') { string += '&' + item + '=' + defaults[item] }
		}
	}
						  
	return string
}


/* Grabs all form field values and creates one url parameterstring
 * Do some validation checking of the values and combinations
 * If there is invalid value, set error to true and an error msg
 * If values are valid, then create url paramstring
 * Deep validation checking is done in the lambda function
 *
 * return 'invalid' if invalid values found
 * return paramstring if valid
 */
function set_paramstring () {

	let error = false
	let msg

	walletvalue = document.getElementById("nodewallet").value
	startblockvalue = document.getElementById("startblock").value //1st leaser block
	stopblockvalue = document.getElementById("stopblock").value //stopblock
	payblockvalue = document.getElementById("payblock").value //startblock
	feesharevalue = document.getElementById("feeshare").value
	rewardsharevalue = document.getElementById("rewardshare").value

	//Start validation checking (startblockvalue | payblockvalue | stopblockvalue)
	if (walletvalue == '' || startblockvalue == '' || payblockvalue == '' || stopblockvalue == '' || feesharevalue == '' || rewardsharevalue == '') {
				error = true
				msg 	= 'Empty fields detected'
	} else if (payblockvalue < startblockvalue) {
				error = true
				msg		= 'Startblock can not be smaller then 1st leaser block'
	} else if (stopblockvalue < payblockvalue) {
				error = true
				msg		= 'Stopblock can not be smaller then startblock'
	} else if (stopblockvalue == payblockvalue) {
				error = true
				msg 	= 'Stopblock can not be startblock, nothing to do'
	} else if (stopblockvalue > currentblock-1) {
				error = true
				msg		= 'Stopblock out of range. Current blockchainheight = ' + currentblock
	} else if ((stopblockvalue - payblockvalue) > maxblocks) {
				error = true
				msg 	= 'Maximum number of blocks to collect : ' + maxblocks
	}

	
	if (!error) {

		const wallet 			= 'wallet=' + walletvalue
		const startblock 	= 'startblock=' + startblockvalue
		const stopblock 	= 'stopblock=' + stopblockvalue
		const payblock 		= 'payblock=' + payblockvalue
		feeshare					= 'feeshare=' + feesharevalue
		rewardshare 			= 'rewardshare=' + rewardsharevalue
		const reset 			= 'reset=' + document.getElementById("overwrite").checked
		const pay 				= 'pay=' + document.getElementById("pay").checked
		const blocks			= 'blocks=' + (stopblockvalue-payblockvalue)
		const force				= 'force=' + document.getElementById("force").checked

		const string 			= '?' + wallet +
							  				'&' + startblock +
							  				'&' + stopblock +
							  				'&' + payblock +
							  				'&' + blocks +
							  				'&' + feeshare +
							  				'&' + rewardshare +
							  				'&' + reset +
							  				'&' + force +
							  				'&' + pay

		return string

	} else {
			alert(msg)
			return 'invalid'
	}
}

/* GET next run batch data
 * If all works as normal, the result should already have loaded
 * when the client logs in.
*/
const reload_next = async () => {

	const value = document.getElementById("nodewallet").value
	
	if (value != '' && value != null && value != undefined) {

		const paramstring 	= '?loadnextrun=true'
		const endpoint 		= baseapi + stage + GET_path

		const options = {
			method: 'GET',
			credentials: 'include'
		}
	
		spinner(run='start', 'reloadnext')

    try {
    	const response = await fetch(endpoint + paramstring, options)
    	const data = await response.json()
    	const bd = data.batchdata
    	const defaults = data.defaults
    	const br = data.browserreload

    	//Function that sets the value for the formfield
    	const setvalue = function (label, val) {
    		const id = document.getElementById (label)
    		id.value = val 
    	}
    	
    	if (defaults) {  //Settings were returned for default values
							for (const key in defaults) {
									let exist = document.getElementById(key) //Check if key exists in form
									if (exist != null) {
											exist.value = defaults[key]
									}
							}
			}

			setvalue('nodewallet', data.wallet)

    	if (bd) {  //Settings were returned for batchdata
					setvalue('payblock', bd.paystartblock)
        	setvalue('stopblock', bd.paystopblock)
        	if (document.getElementById("force").checked) { document.getElementById("stopblock").value = document.getElementById("lastblock").placeholder - 1 }
        	setvalue('startblock', bd.scanstartblock)
        	document.getElementById('startblock').disabled = true
    	}

    	if (data.wallet) { document.getElementById('nodewallet').disabled = true }
      if (data.alert)  { alert(data.alert) }
      if (br == true) { window.location.reload(true) } //Reload frontend

    } catch (err) {
			console.log(err)
    }
    spinner(run='stop', 'reloadnext')

  } else { alert('Please login') }
}


/* GET API request
 * This is an asynchronous function
 * the results will not be seen
 * client will get email with signed-urls
 * CORS need to be enabled on the API gateway or
 * options { mode: no-cors } can be set in here 
 * input: mywavespaymenttxid = txid of waves wldaas payment for reference
 *
 * params;
 * - default proceed is false. If true then payment was done and cookie expired,
 *   start collector without parameters that were stored in globalobject
 */
const start_collect_run = async (proceed=false) => {

			const endpoint 		= baseapi + stage + GET_path
			const options = {
				method: 'GET',
				credentials: 'include',
			}
			let paramstring


			if (proceed == false) {	//Normal collector run
				paramstring = set_paramstring()
			}

			try { //Check if we need to proceed because cookie expired and payment was done
					const wavestxid = globalobject['mywavespaymenttxid'] //If wavestxid is available, send along, the payment was done while cookie expired
					paramstring = globalobject['paramstring']
					paramstring += '&mywavespaymenttxid=' + wavestxid  //This is used to let lambda detect the payment was already done
					//alert('found wavestxid')

			} catch(error) {
					//alert('start run without wavesTxid')
			}

			//console.log(paramstring)
			//alert(paramstring)
			
			spinner(run='start', 'collect')

  		try {	//Start collector run API request
    		const response = await fetch(endpoint + paramstring, options)
    		const data = await response.json()

    		//console.log(data)
    		if (data.wavestxid) {  //If cookie expired, lambda returns in body resp_body['wavestxid']
    			if (data.wavestxid == 'delete_key') { delete globalobject['mywavespaymenttxid'] }	//Delete if a proceed was already started and avoid looping
    		}
    		if (data.alert)  { alert(data.alert) }

    		if (data.browserreload) {	//cookie expired

    				if (data.wavestxid != 'delete_key') { //Catch wavestxid and paramstring to be picked up after reload

      				const url = window.location.href.split('?')[0]  //Get url without params
      				const params = '?setglobalobject=' + btoa(JSON.stringify(globalobject)) //Stringify, create base58 hash
      				window.history.pushState({}, document.title, "/" + params) //Add hash url, reload browser
      			}
    				window.location.reload(true) //Reload frontend
    		}
    		spinner(run='stop', 'collect')

    	} catch (err) {
				console.log(err)
				alert('Something went wrong while starting collector.\nContact your admin.\nWaves Tx ID:\n[ ' + mywavespaymenttxid + ' ]')
    	}
}


/* Method to login to WLDaaS portal
 * POST request with login details
 * Response is body with auth key if succesfull, else alert data
 * If old collector data is found, is is returned in the body
 * An url is constructed from the body data and the page is reloaded
 * The url params are set in the frontend formfields
*/
const login_account = async () => {

		let loggedin = false
		const value = document.getElementById("nodewallet").value //Get wallet address
		if (value != '' && value != null && value != undefined) { //Client Login is already active
			loggedin = true
		}

		const name 			= document.getElementById("username").value
		const pwd 			= document.getElementById("password").value
		const waveswallet	= document.getElementById("wallet_signup").value;
		const mailformat	= /^\w+([\.-]?\w+)*@\w+([\.-]?\w+)*(\.\w{2,3})+$/;

		let invalid 	= true
		let invalidmail = false

		if ( name.length > 0 && pwd.length > 0 && waveswallet.length ) { //All fields are filled

			if (name.match(mailformat)) {	//Valid mail format used
		 		invalid = false				//Overall validation is ok
		 		invalidmail = false
			} else { invalidmail = true; invalid = false }
		}

		if ( invalidmail === true ) {
			alert(' Invalid email format used: ' + name)
		} else if ( loggedin == true ) {
				alert(' Already logged in.')
		} else if ( invalid === true ) {
    		alert(' Need wallet, username & password to login!')
		} else {  //Proceed with login request

					//Create base64 string for password to avoid special character confusion
					const paramstring 		= "wallet=" + waveswallet + "&username=" + name + "&password=" + btoa(pwd)
					const encoded_secret	= btoa(paramstring) //create base64 string
					const loginsecret			= { "loginsecret" : encoded_secret }
    			const endpoint 				= baseapi + stage + account_path + login
					const options				= { 
																	method: 'POST',
																	credentials: 'include',
																	mode: 'cors',
																	headers: {
																			"Content-type": "application/json; charset=UTF-8"
																	},
																	body: JSON.stringify(loginsecret)
																}

					spinner(run='start', 'login')

    			try {
    					const response = await fetch(endpoint, options)			
    					const data = await response.json() //This is the body of the response
        			//console.log(data)



        			if (data.auth) {	//auth key found, it is a succesfull login

        					if (globalobject['mywavespaymenttxid']) {  //Cookie expired while payment was done. Proceed to collector

        						document.getElementById("nodewallet").value = waveswallet //Needed to detect we are logged in
        						start_collect_run(proceed=true)  //Started automatically when cookie expired and payment was done
        						delete globalobject['mywavespaymenttxid']  //delete to avoid repeated collector runs

        					} else {  //Normal login succeeded

        						if (data.alert)  { alert(data.alert) }
        						const urlstring = create_paramstring_from_body (data) + '&username=' + btoa(name)
        						window.history.pushState({}, document.title, "/" + urlstring)	//Add params to browser URL
        						//alert(document.cookie)
        						window.location.reload(true) //Reload frontend
        					}
        			} else if (data.alert)  { alert(data.alert) }	//No succesfull authentication

        	} catch (err) {
							console.log(err)
    			}
    			spinner(run='stop', 'login')
    	}
}


/* POST API request
 * This is an asynchronous function
 *
 * Some info about CORS;
 * CORS need to be enabled on the API gateway
 * With Integration setup as Lambda-Proxy,
 * the header for cross-origin needs to be setup on the lambda function itself.
 * 'Access-Control-Allow-Origin': '*'
 * The API gateway transfers all headers to the lambda function
 * The OPTION request (preflight) is handled by the API gateway MOCK integration 
 * If the lambda function crashes (i.e. has invalid key declarations),
 * the respons fails and in the browser you see error 403.
 * Then the browser will miss the header 'Access-Control-Allow-Origin': '*'
 * and the POST request will never be send by the browser
 */
const create_account = async () => {

	let activation = false
	let invalid = true //Check if formfields are set correctly
	let signupwallet //wallet
	let signuphash //temporary hash for signup confirmation
	let invalidmail = false //invalid email address indicator
	let name //username
	let pwd //password
	let jsonbody
	let allempty = true
	const repeatpwd = document.getElementById("repeatpwd")
	
	if (repeatpwd.hidden == true && !secret) { 
		repeatpwd.hidden = false 
	}
	else if (repeatpwd.hidden == false && !document.getElementById("repeatpwd").value) {
		repeatpwd.hidden = true
	}
	else { //BEGIN signup

		if (secret) { //Someone clicked his activation link in the email
			decoded_secret = atob(secret) //Decode the base64 string
			signupwallet = new URLSearchParams(decoded_secret).get('wallet')
			signuphash = new URLSearchParams(decoded_secret).get('signuphash')
			name = new URLSearchParams(decoded_secret).get('username')

			if (!name) { alert ('no name present, malformed url') }
			invalid = false
			activation = true
	
		} else { //No activation, signup form used

			name 			= document.getElementById("username").value
			pwd 			= document.getElementById("password").value
			repeatpwd.value	= document.getElementById("repeatpwd").value
			signupwallet	= document.getElementById("wallet_signup").value;
			mailformat	= /^\w+([\.-]?\w+)*@\w+([\.-]?\w+)*(\.\w{2,3})+$/;

			if ( name.length > 0 && pwd.length > 0 && signupwallet.length == 35 && pwd.length > 0 && repeatpwd.value.length > 0 ) { //All fields are filled

				allempty = false 

				if ( name.match(mailformat) && pwd == repeatpwd.value ) {	//Valid mail format used and passwords match
		 			invalid = false				//Overall validation is ok
				} else if (!name.match(mailformat)) {
					invalidmail = true
				} else if (pwd != repeatpwd.value) {
					unequalpwd = true
				}
			}
		}

		if (activation) {
			jsonbody = { wallet: signupwallet, username: name, signuphash: signuphash }
		} else {
			jsonbody = { username: name, password: pwd, wallet: signupwallet }
		}

		if ( invalid === false ) {  //All values valid, request signup call

			const endpoint 		= baseapi + stage + account_path + signup
			const options		= { 
				method: 'POST',
				mode: 'cors',
				headers: {
					"Content-type": "application/json; charset=UTF-8"
				},
				body: JSON.stringify(jsonbody)
			}

    		try {
    			spinner(run='start', 'create')
    			const response = await fetch(endpoint, options)				
    			const data = await response.json() //This shows the body of the response
    			spinner(run='stop', 'create')
        		//console.log(data)
        		alert(data)
        		const url = window.location.href.split('?')[0]  //Get url without params
        		window.history.pushState({}, document.title, "/")
        		window.location.reload(true) //Reload frontend
        	} catch (err) {
				console.log(err)
				spinner(run='stop', 'create')
    		}
    	} else if ( allempty === true ) {
    		alert(' Need wallet, username & password to sign up!')
		} else if ( invalidmail === true ) {
			alert(' Invalid email address used: ' + name)
		} else if ( unequalpwd === true ) {
			alert(' Password are different.')
		}
	} //END signup

}


const find_1st_leaser = async () => {

	const baseurl = wavesnodes + activeleases
	const wallet = document.getElementById('nodewallet').value

	if (wallet != undefined && wallet != '' && wallet != null) {	//Start if wallet address

		let oldestblock = 0
		const id = document.getElementById ('startblock')
		const lastblock = document.getElementById('lastblock').placeholder

		try {
			const response = await fetch (baseurl + '/' + wallet)
			const data = await response.json()
			//console.log(data)

			if (data.length == 0) {  //No leases found, set lastblock as 1st leaser block
    			id.value = lastblock
    			alert('No active leases found.\nCurrent lastblock used [' + lastblock + ']')
			}
			else {  //Findingfirst leaser block
				for (index in data) {
					newheight = data[index]['height']
					if (index == 0) { oldestblock = newheight }
					if (newheight < oldestblock) { oldestblock = newheight }
				}
				if (id.disabled == true) {  //Formfield startblock is disabled
					alert('1st leaser block already stored.\n' +
						  'Unlock if you want to overwrite.')
				}
				else { //Formfield unlocked, set value to oldest leaseblock found
					id.value = oldestblock
					alert('First leaser block found: ' + oldestblock)
				}
			}
		}
			catch (err) {

		}

	}	//End if wallet address
	else {
		alert('No wallet address defined.\nLogin or load nextrun data first.')
	}
}


const unlock_1st_leaser = function () {

	const sb = document.getElementById ('startblock')
	
	if (sb.disabled == true) { sb.disabled = false }

}


const go_settings_page = function () {

	const value = document.getElementById("nodewallet").value
	
	if (value != '' && value != null && value != undefined) {

		const url = window.location.href.split('?')[0]  //Get url without params
		const params = '?wallet=' + value + '&settings=load'
		//alert(params)
    window.history.pushState({}, document.title, "/" + settingspage + params)
    window.location.reload(true) //Reload frontend
	
	} else { alert('Please login') }

}


const go_page = function (pagename) {

	const value = document.getElementById("nodewallet").value

	if (value != '' && value != null && value != undefined) {

		const params = '?wallet=' + value
    window.history.pushState({}, document.title, "/" + pagename + params)
	
	} else { window.history.pushState({}, document.title, "/" + pagename ) }

	window.location.reload(true) //Reload frontend

}


const go_password_change = function () {

	let params = ""
	const object = { "nodewallet" : document.getElementById("nodewallet").value,
									 "username"		: globalobject['usernameb64'] }

	for (key in object) { 
		const value = object[key]
		if (value != '' && value != null && value != undefined) {
			if (params == "") { params = "?" } else { params += "&" }
			params += key + "=" + value
		}
	}
  window.history.pushState({}, document.title, "/" + pwdchange_page + params)
  window.location.reload(true) //Reload frontend
}




/* Method to configure default tool settings
*/
const configure = async () => {

	const settings		= 'settings=true'
	const paramstring 	= '/?' + settings
	const endpoint 		= baseapi + stage + GET_path

	const options = {
		method: 'GET',
		credentials: 'include'
	}
	
    try {
    	const response = await fetch(endpoint + paramstring, options)
    	const data = await response.json()
        //console.log(data)
        if (data.alert)  { alert(data.alert) }
        //window.location.reload(true) //Reload frontend
    } catch (err) {
		console.log(err)
    }
}


const waves_keeper_transaction = async (wled_price, receiver, txattachment, myfunction) => {

	const mystring = makeid(30) //This random string is used for waveskeeper signing
	const price = wled_price
	let alerttext

	//These three lines are to start collector without payment
	//const mywavespaymenttxid = "cDVwEZd7gCofCjL7FzqPTyFRMt7n1pH5dQnDmRYbCvq" //last char was q//txid of transaction for WLDaaS revenue
	//globalobject['mywavespaymenttxid'] = mywavespaymenttxid
	//myfunction()


	// NOTE
	// attachment in a signer transfer call should be given as string, not as base58.
	// Apparently it is converted to base58 internally by signer
	
	requirejs(['signer', 'provider-keeper'], function({ Signer }, { ProviderKeeper }) {
		signer = new Signer({ NODE_URL: wavesnodes });
		keeper = new ProviderKeeper({ data: mystring });
		signer.setProvider(keeper);
		signer.transfer({amount: price, recipient: receiver, attachment: txattachment}).broadcast().then(
			function (txresult) {  //This is the Signed object that was transacted by Waves Keeper
				//console.log(txresult[0])
				const mywavespaymenttxid = txresult[0].id //txid of transaction for WLDaaS revenue
				globalobject['mywavespaymenttxid'] = mywavespaymenttxid
				myfunction()
			}
		).catch(
			function (error) {
				console.log('Payment was unsuccesfull.')
				console.log(error)

				if (error.code) {
					if (error.code == 1004) { alerttext = 'Transaction rejected.' }
				}
				else if (error.error) {
					if (error.error == 112) { alerttext = 'Insufficient funds in wallet.'}
				}
				alerttext += '\nNo payments done.\nNo collector task started.'
				alert(alerttext)	

				spinner(run='stop', 'collect')			
			}
		)

	})  //END requirejs */

};



const waves_keeper_masstransaction = async (masstxdata, myfunction=console.log()) => {

	const mystring = makeid(30) //This random string is used for waveskeeper signing
	let alerttext

	// NOTE
	// attachment in a signer transfer call should be given as string, not as base58.
	// Apparently it is converted to base58 internally by signer
	
	requirejs(['signer', 'provider-keeper'], function({ Signer }, { ProviderKeeper }) {
		signer = new Signer({ NODE_URL: wavesnodes });
		keeper = new ProviderKeeper({ data: mystring });
		signer.setProvider(keeper);
		signer.massTransfer(masstxdata).broadcast().then(
			function (txresult) { //This is the Signed object that was transacted by Waves Keeper
				//console.log(txresult[0])
				const wavestxid = txresult[0].id //txid of masstransaction
				myfunction(wavestxid)
			}
		).catch(
			function (error) {
				console.log('Payment unsuccesfull.')
				console.log(error)

				if (error.code) {
					if (error.code == 1004) { alerttext = 'Transaction rejected.' }
				}
				else if (error.error) {
					if (error.error == 112) { alerttext = 'Insufficient funds in wallet.'}
				}
				alerttext += '\nPayment unsuccesfull.\nJust retry again by using the link in the email.'
				alert(error)

				alert(alerttext)
			}
		)

	})  //END requirejs

};



/* This function returns a promise
 * It requests a unique id that is needed
 * for the paytransaction in the attachment
 * When the collector run request is activated
 * the pay transaction can be validated on the 
 * blockchain
 * We also need the requested payblock and the
 * toggle switch overwrite value.
 * Lambda determines if the values makes sense
 * to proceed or they need change and returns
 * modified values to frontend
 */
const get_unique_pay_id = async () => {

	const payblock 		= document.getElementById('payblock').value
	const reset 			= document.getElementById('overwrite').checked
	const getpayid		= 'getuniquepayid=true'
	let paramstring 	= '/?' + getpayid + '&prevleaseinfoblock=' + payblock + '&reset=' + reset
	const endpoint 		= baseapi + stage + GET_path
	if (globalobject['freerun'] == true) { paramstring += '&freerun=true' }

	const options = {
		method: 'GET',
		credentials: 'include'
	}

	spinner(run='start', 'collect')

	try {
		const response = await fetch(endpoint + paramstring, options)
    const data = await response.json()
    //console.log(data)
    if (data.alert)  { alert(data.alert) }
    if (data.uniquepayid) {
    	//console.log(data.uniquepayid)
    	const uniquepayid = data.uniquepayid
    	return uniquepayid
    } else if (data.browserreload) {
    	return 'browserreload'
    }
  }
		catch (err) {
			console.log(err)
			myerrormsg = { "error" : "Payment processor error. Can not proceed." }
			return myerrormsg
  }
  spinner(run='stop', 'collect')

}





const click_button_collect = async () => {

	globalobject['freerun'] = document.getElementById("freerun").checked
	const value = document.getElementById("nodewallet").value //Get wallet address

	if (value != '' && value != null && value != undefined) { //Client Login is active

		if (document.getElementById("force").checked) { document.getElementById("stopblock").value = currentblock-1 } //Set last block to stopblock

		let paramstring 	= set_paramstring() //This returns the url arguments for the api server request
		if (paramstring != 'invalid') { //---------- Begin No Incorrect values were found

			globalobject['paramstring'] = paramstring //Set paramstring to be available when cookie expire occured and payment was done
			if (globalobject.mywavespaymenttxid == undefined || globalobject.mywavespaymenttxid == null) { //******* Begin if not exists, no cookie expired, need normal processing with payment 

					const requestedpayblock = document.getElementById("payblock").value //Used to check if there is a previous leasinfo file
					const uniquepayid = await get_unique_pay_id() //Get unique string to be used as txs attachment

					if (uniquepayid == 'browserreload') {
						window.location.reload(true)
					} else if (uniquepayid.freerun) {	//Check what was the answer on the freerun request

						if (uniquepayid.freerun == 'accept') {	//Free run was accepted.


							const result = handle_previous_leasedata_inconsistency (uniquepayid, requestedpayblock)
							if (result == 'exit') { return } //Exit click collect function

							//Since it is a freerun, there is no Waves transaction done
							//We will therefore set the expected WLDaaS paymentId as wavestxid in the url
							//Lambda will detect it is a freerun request and will not do validation checking on the waves blockchain
							globalobject['mywavespaymenttxid'] = uniquepayid.utf8
							//globalobject['freerun'] == false
							spinner(run='start', 'collect')
							start_collect_run()	//Start collector without waves payment

						} else {
							alert('A Free run is not accepted at this time. Sorry.')
							spinner(run='stop', 'collect')
							return
						}

					} else { //No freerun, it's a payed run

						const result = handle_previous_leasedata_inconsistency (uniquepayid, requestedpayblock)
						if (result == 'exit') { return } //Exit click collect function

						let colprice
						const value = document.getElementById("pay").checked
						if (value == true) {
							colprice = mypaydetails.collectandpayprice
						} else {
							colprice = mypaydetails.collectorprice
						}

						const txfee = mypaydetails.txfee
						const rxwallet = mypaydetails.wallet

						const msg = 'Service pricing:\n' +
												'-------------------------------------------\n' +
												' - collector run : ' + exptodec(wp(colprice)) + ' Waves\n' +
												' - tx fee : ' + exptodec(wp(txfee)) + ' Waves\n' +
												'   totals : ' + exptodec(wp(colprice+txfee)) + ' Waves\n' +
												'-------------------------------------------\n' +
												'After payment the collector starts.\n' +
												'\nProceed to payment via Waves Keeper?\n'

						if (confirm(msg)) { //Service request confirmed
							//alert(uniquepayid.base58)		 
							waves_keeper_transaction(colprice, rxwallet, uniquepayid.utf8, start_collect_run)
						} else {
							//Payment Cancelled
							spinner(run='stop', 'collect')
							console.log('Collector run request was cancelled.')
						}
					}

			} else { //There is a wavestxid, use that to start collector. payment was already done, but cookie expired
					start_collect_run(proceed=true)
			}  //******* End if not exists, no cookie expired, need normal processing with payment

		} //---------- End No Incorrect values were found	

	} else { //No wallet value set, Client needs to login
			alert('Please login.')
	}
}


/*
const axios_get = async (url) => {

	const xhttp = new XMLHttpRequest();
	xhttp.onreadystatechange = function() {
		if (this.readyState == 4 && this.status == 200) {
       // Typical action to be performed when the document is ready:
       //document.getElementById("demo").innerHTML = xhttp.responseText;
       console.log('Retreived Waves masstransfer data from s3.')
       console.log(xhttp.responseText)
    }
   }
  xhttp.open("GET", url, true);
	xhttp.send();
}
*/


//Function that GETs a file
//It returns the json content
//If fails throws error
const fetch_json_data = async (url) => {

	const options = {
		method: 'GET',
		mode: 'cors',
	}
	
	try {
		const response = await fetch(url, options)
		const jsondata = response.json()
		return jsondata
		//window.location.reload(true) //Reload frontend
	} catch (err) {
		console.log('Caught an error while fetching ', url)
		console.log(err)
		throw(err)
	}
}


//Main funcion that handles are sub functions to execute
//a Waves masstransfer.
//The s3 presigned url is decoded back from base64 to 'normal'
//The presigned url is requested and response is a file which
//contains all arrays with transfer data, nicely prepared in chunks.
//Chunk size is the maximum recipients (100) in a masstransfer
//The received transferdata is used in the waveskeeper to sign
//and broadcast.
const waves_masspayment_main = async () => {

	const s3_presigned_url	= atob(wavespaylink) //Decode base64 bytes to original presigned s3 url

	try {
		const result = await fetch_json_data(s3_presigned_url) //Array with all masstransfer objects
		const masstransfers = result.length //How many masstransfers we will do
		for (let i = 0; i < masstransfers; i++) {
    	//console.log(result[i]); //Show the masstransferobject
    	for (const masstxname in result[i]) {
    		const masstxobject = result[i][masstxname]
    		console.log('Offer masstransaction \'' + masstxname + '\' to Waves keeper..')
    		waves_keeper_masstransaction ( masstxobject )
    	}
		}

	} catch (err) {
		throw err
	}


}



/*
 * This function reads the lambda respons on the get_unique_payid function
 * Lambda could propose block value adaption when there are no previous leasedata files found
 *
 * If cancel was clicked, 'reset' is returned, else nothing is returned
*/
function handle_previous_leasedata_inconsistency (uniquepayid, requestedpayblock) {

	const reset = document.getElementById("overwrite").checked
	const firstleaserblock = document.getElementById("startblock").value

	if (uniquepayid.previousleaseinfo) {  //Found inconsistent alignment between requested start and previous leaseinfo files
			const prevleaseblock = uniquepayid.previousleaseinfo
			const reverttofirstleaser = uniquepayid.isfirstleaserblock //If this is 'yes', prevleaseblock = 1st leaser block detected

			if (prevleaseblock == requestedpayblock) { //Requested block has previous lease file available
					console.log('Found previous leasedata file for startblock ' + requestedpayblock + ', this is good :-)')

			} else if (prevleaseblock == 'forcerequested') { //Overwrite was requested and previous leasedata files were neglected
					if (requestedpayblock != firstleaserblock) { //Dangerous, chance of miss out of first leaser
							const msg = 'WARNING\nThe requested startblock (' + requestedpayblock + ') is different\n' +
													'from the 1st leaser block (' + firstleaserblock + ').\n' +
													'If lease activity occured before the requested startblock\n' +
													'you will miss out on these lease transactions.\n' +
													'\nAre you sure you want to start this run?'

							if (confirm(msg)) { //Service request confirmed, force start from requested block
									console.log('WARNING: requested block <> 1st leaser block.\nCollector run forced start from block ' + requestedpayblock)
							} else { //Cancel task request
									spinner(run='stop', 'collect')
									return 'exit'
							}

					} else { //1st leaserblock is same as requested payblock
							const msg = 'There were previous leasedata files available.\n' +
													'These are neglected and we will start from ' + requestedpayblock + '\n' +
													'This is safe to execute as long as the 1st leaser block\n' +
													'is exact or lower then where you received the 1st\n' +
													'leaser. If not, you will miss out on lease transactions.'

							if (confirm(msg)) { //Service request confirmed, force start from requested block
									console.log('Collector run forced start from block ' + requestedpayblock)
							} else { //Cancel task request
									spinner(run='stop', 'collect')
									return 'exit'
							}		

					}

			} else if (prevleaseblock == 0) { //No previous leasefile at all and no leasers
					if (document.getElementById("startblock").value != requestedpayblock) { //Startblock !eq requested block, need change
							const msg = 'Found no previous leaseinfo files and found no leasers yet.\n' +
													'This seems the first run, requested startblock : ' + requestedpayblock +
													'\n\nSet 1st leaser block and startblock to ' + requestedpayblock +
													'\nand start collector run?'

							if (confirm(msg)) { //Service request confirmed		 
									document.getElementById("startblock").value = requestedpayblock
									paramstring = set_paramstring() //reset paramstring due to changed 1st leaser block
									globalobject['paramstring'] = paramstring

							} else { //Cancel task request
									spinner(run='stop', 'collect')
									return 'exit'
							}
					}

			} else if (prevleaseblock > 0 && reverttofirstleaser == 'yes') { //No leasefiles available but detected 1st leaser block
					document.getElementById("startblock").value = prevleaseblock //Set 1st leaser block value
					document.getElementById("payblock").value = prevleaseblock //Set same as 1st leaser
					const msg = 'Found no previous leaseinfo files. However, detected a 1st\n' +
											'leaser block : ' + prevleaseblock + '.\n' +
											'Scanning will start from there.'

					paramstring = set_paramstring() //reset paramstring due to changed 1st leaser block
					globalobject['paramstring'] = paramstring

					console.log(msg)
					alert(msg)

			} else { //Requested Previous file not available but found a nearest one which is safe to use 
					const msg = 'The requested startblock (' + requestedpayblock + ') has no previous\n' +
											'leasedata stored. The nearest lower leasedata file available\n' +
											'is from block ' + prevleaseblock + '.\n' +
											'\nDo you want to start the collector from the proposed block?'

					if (confirm(msg)) { //Service request confirmed		 
							document.getElementById("payblock").value = prevleaseblock //Set to nearest found block
							paramstring = set_paramstring() //reset paramstring due to changed 1st leaser block
							globalobject['paramstring'] = paramstring
							console.log('Collector run started from nearest lower leasedata : ' + prevleaseblock)

					} else { //Cancel task request
							spinner(run='stop', 'collect')
							return 'exit'
					}				
			}
	}
}




if (secret != undefined && secret != '' && secret != null) { //Someone clicked on the activation link in the email he/she received
	console.log('Starting signup validation...')
	create_account();
}
else if (wavespaylink != null && wavespaylink != '') { //Someone clicked on the leaser payout link in the collector email

	console.log('Spotted waves transaction. Will start Waves Keeper signing and broadcast...')
	//console.log(wavespaylink)
	waves_masspayment_main()
	}




</script>


  </body>

</html>